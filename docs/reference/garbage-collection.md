# 垃圾回收（Garbage Collection）

垃圾回收（GC）是自动内存管理机制，它会回收“已经不可能再被使用”的对象。

## 引用计数（Reference Counting）

最简单的做法是给每个对象一个计数：

* 有一个新引用指向它，计数 +1。
* 引用消失，计数 -1。
* 计数为 0 时释放。

问题是：**循环引用**会让计数永远不为 0。

```javascript
let a = {};
let b = {};
a.other = b;
b.other = a;
```

## 可达性分析（Tracing / Mark & Sweep）

现代 JS 引擎通常采用“可达性分析”：

* 以全局对象、调用栈等为根（root）。
* 从根出发，能到达的对象都“活着”。
* 无法到达的对象就是垃圾。

这种方法能处理循环引用。

## 内存泄漏（Memory Leak）

即使有 GC，也可能泄漏：对象一直“可达”，但逻辑上早已没用。

常见原因：

* 全局变量过多。
* 事件监听未移除。
* 缓存无限增长。
* 闭包长时间持有大对象。

## 简单建议

* 用完的引用设为 `null`。
* 给缓存设置上限。
* 事件监听及时移除。
* 临时映射用 `WeakMap` / `WeakSet`。

## 进一步阅读

理解 GC 与引用，会帮助你理解“对象生命周期”和性能问题。
