# 引用

> 注：本文中提及到的引用，是广义的“引用[^1]”概念，而不仅仅是C++的引用[^2]。

简单一点讲，引用是一种关系，比如，本文中引用了大量的Wikipedia词条，每一个链接对应下来就是一个“引用”。这种链接关系，就可以叫做引用。

这个概念其实很简单，比如我要完成这篇文章，有些事情说不明白的，可能需要参考Wikipedia的解释，这个时候有两种办法，一种是通过引文的方式摘取一段相关的文字，另一种方式就是直接给出链接。

这两种都可能带来一些问题。比如前者，如果引文部分在Wikipedia做了修改，这边是不能够自动做同步的；比如后者，通过链接引用自然不需要专门去对内容修改与否做特别的关注，但是如果所链接的内容直接被删除了，也是一个很糟糕的事情：毕竟原文不在了，又没有引文，这样基本上就没有任何地方可以还原回来你期望引用的内容了。

编程中也有类似的概念与之对应。比如你要取一个序列中的特定位置的元素，一种办法是直接取出来，复制给某一个变量。另外一种就是记录一个位置信息，每次要用的时候再去取。

同样地也有之前我们提到的两个问题：要么，对方更新了你得不到同步；要么双方之间通过一个位置信息做关联，但实际的数据丢失了。


## 复制与引用

### 内存空间

其实我们可以简单地把程序运行的内存空间看做一个由字节组成的特别大的序列。每个变量其实对应到这些序列中特定的连续的一段空间。

比如：

|序号|内容|
| -- | -- |
| 0xDEADBE00 | DE |
| 0xDEADBE01 | AD |
| 0xDEADBE02 | BE |
| 0xDEADBE03 | EF |

假设这段空间可以用来表示一个32的整数，同时假设是Big Endian[^3]的字节序（Byte Order）。那么这段空间就可以用来表示数字`3735928559`(0xDEADBEEF)，如果是一个长度为4的字符串，那么就是`" ޭ��"`（`"\xDE\xAD\xBs dE\xEF"`）。

### 复制

在这种情况下，如果我们定义两个变量a和b，其实就是处在内存的不同位置上。当我们选择把a赋值给b的时候，相当于把a所处空间的内容，依次放到b所对应的空间中去。

其实也就相当于把a的内容**复制**了一份给了b。


[^1]: https://en.wikipedia.org/wiki/Reference_(computer_science)
[^2]: http://en.cppreference.com/w/cpp/language/reference

[^3]: https://en.wikipedia.org/wiki/Endianness



