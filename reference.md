# 引用

> 注：本文中提及到的引用，是广义的“引用[^1]”概念，而不仅仅是C++的引用[^2]。

简单一点讲，引用是一种关系，比如，本文中引用了大量的Wikipedia词条，每一个链接对应下来就是一个“引用”。这种链接关系，就可以叫做引用。

这个概念其实很简单，比如我要完成这篇文章，有些事情说不明白的，可能需要参考Wikipedia的解释，这个时候有两种办法，一种是通过引文的方式摘取一段相关的文字，另一种方式就是直接给出链接。

这两种都可能带来一些问题。比如前者，如果引文部分在Wikipedia做了修改，这边是不能够自动做同步的；比如后者，通过链接引用自然不需要专门去对内容修改与否做特别的关注，但是如果所链接的内容直接被删除了，也是一个很糟糕的事情：毕竟原文不在了，又没有引文，这样基本上就没有任何地方可以还原回来你期望引用的内容了。

编程中也有类似的概念与之对应。比如你要取一个序列中的特定位置的元素，一种办法是直接取出来，复制给某一个变量。另外一种就是记录一个位置信息，每次要用的时候再去取。

同样地也有之前我们提到的两个问题：要么，对方更新了你得不到同步；要么双方之间通过一个位置信息做关联，但实际的数据丢失了。


## 复制与引用

### 内存空间

其实我们可以简单地把程序运行的内存空间看做一个由字节组成的特别大的序列。每个变量其实对应到这些序列中特定的连续的一段空间。

比如：

|序号|内容|
| -- | -- |
| 0xDEADBE00 | DE |
| 0xDEADBE01 | AD |
| 0xDEADBE02 | BE |
| 0xDEADBE03 | EF |

假设这段空间可以用来表示一个32的整数，同时假设是Big Endian[^3]的字节序（Byte Order）。那么这段空间就可以用来表示数字`3735928559`(0xDEADBEEF)，如果是一个长度为4的字符串，那么就是`" ޭ��"`（`"\xDE\xAD\xBs dE\xEF"`）。

### 复制

在这种情况下，如果我们定义两个变量a和b，其实就是处在内存的不同位置上。当我们选择把a赋值给b的时候，相当于把a所处空间的内容，依次放到b所对应的空间中去。

其实也就相当于把a的内容**复制**了一份给了b。当然，对于一个32位的整数来说，相当于复制了4个字节。对于一个长度为10的32位整数array来说，相当于复制了$$4\times10$$也就是40个字节。对于其他类型的数据当然也是根据其类型和内容来确定复制的字节数量。

当然在引用出现之前，复制做到这么简单易懂是最好的了。

### 引用

试想这样一个结构：一个长度为100，array其元素的类型是一个长度为100的32位整数array。也就是`array<array<int, 100>, 100>`。大致看上去可以当成一个$$100\times100$$的矩阵。

如果这样类型的两个变量之间相互赋值，参与复制的就是$$4\times100\times100$$个字节。假设每次只能复制一个字节的话，一个简单的赋值操作就要进行40000次复制。当然对于实际应用程序来说，这只是一些很小的数据，但也足够引起重视了。

如果我们用前面提到的思路，只通过数据在内存这个超大的序列中的位置以及其类型来表示该数据，这样对于这种大型数据结构，我们就可以节省很多的复制时间和空间占用了。

C++的指针（Pointer）就可以作为这样一种结构来达到我们期望的效果

```C++
using matrix_t = array<array<int, 100>, 100>;
matrix_t matrix {};

matrix_t* matrix_pointer = &matrix;
```

[^1]: https://en.wikipedia.org/wiki/Reference_(computer_science)
[^2]: http://en.cppreference.com/w/cpp/language/reference

[^3]: https://en.wikipedia.org/wiki/Endianness



