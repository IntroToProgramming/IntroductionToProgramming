<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>编码 | 编程导引</title>
    <meta name="description" content="A VitePress site">
    <link rel="stylesheet" href="/assets/style.cac40d77.css">
    <link rel="modulepreload" href="/assets/Home.b545b89c.js">
    <link rel="modulepreload" href="/assets/app.2fe5d9c1.js">
    <link rel="modulepreload" href="/assets/ch04_encoding.md.869302a4.lean.js">
    <link rel="modulepreload" href="/assets/app.2fe5d9c1.js">
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?c522f795b036ecc6e5446ce20e40ae9f";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
            </script>
    <script>
window.MathJax = {
    tex: {
        inlineMath: [['$', '$']]
    },
    svg: {
        fontCache: 'global'
    }
};

(function () {
    var script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js';
    script.async = true;
    document.head.appendChild(script);
})();
setInterval(() => window.MathJax.typeset(), 700);
</script>
    <meta name="twitter:title" content="编码 | 编程导引">
    <meta property="og:title" content="编码 | 编程导引">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-675d8756><div class="sidebar-button" data-v-675d8756><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/" aria-label="编程导引, back to home" data-v-675d8756 data-v-4a583abe><!----> 编程导引</a><div class="flex-grow" data-v-675d8756></div><div class="nav" data-v-675d8756><nav class="nav-links" data-v-675d8756 data-v-eab3edfe><!--[--><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/intro" data-v-b8818f8c>编程导引 <!----></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-83e92a68><nav class="nav-links nav" data-v-83e92a68 data-v-eab3edfe><!--[--><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/intro" data-v-b8818f8c>编程导引 <!----></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-83e92a68><!--[--><li class="sidebar-link"><a class="sidebar-link-item" href="/intro">引言</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/ch01_environment">环境</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/ch02_computation">计算</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/ch03_procedure">过程</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item active" href="/ch04_encoding">编码</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#二进制">二进制</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#定长">定长</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#ascii">ASCII</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#字符集">字符集</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#十六进制">十六进制</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#ascii-1">ASCII</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#cjk字符集">CJK字符集</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#unicode">Unicode</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#utf-8">UTF-8</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#数系的扩充">数系的扩充</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/ch05_sequence">序列</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/ch06_data">数据</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/ch07_state">状态</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/ch08_reference">引用</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/ch09_closure">闭包</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/ch10_object">对象</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/ch11_concurrency">并发</a><!----></li><!--]--></ul><!--[--><!--]--></aside><!-- TODO: make this button accessible --><div class="sidebar-mask"></div><main class="page" data-v-7eddb2c4><div class="container" data-v-7eddb2c4><!--[--><!--]--><div style="position:relative;" class="content" data-v-7eddb2c4><div><h1 id="编码" tabindex="-1">编码 <a class="header-anchor" href="#编码" aria-hidden="true">#</a></h1><p>这里的编码（Encoding）当然不是指简单的编写代码。</p><p>为什么会有这个概念呢。</p><p>想想古老的印度人是怎么表示数字的吧：用十个不同的符号和位序组合来表示一个确切的数字，演化成今天我们的用阿拉伯数字（Arabic Numerials）表示的十进制系统。</p><p>没错就是你身边到处都存在的<strong>数字</strong>。这套系统只需要简单的十个符号和并不怎么复杂的规则就能从0表示到任意大的确切数字。</p><p>我们在第二讲中提到，代码中的表示的“整数”，跟数学意义上的整数，是有所差距的。这个差距其宗之一就在于表示数字的能力上。</p><p>比如，我们来计算$2^{70}$：</p><div class="language-javascript"><pre><code><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>嗯，结果是什么鬼（<code>1.1805916207174113e+21</code>，特别是后面这段）！</p><p>也就是说，我们能直观表示的整数也就21位（十万亿亿级），再之后就只能用科学计数法表示了。</p><p>实际你会发现，其实还没到这个数量级的时候，数字就已经无法精确表示了。</p><p>为什么会这样呢？</p><h2 id="二进制" tabindex="-1">二进制 <a class="header-anchor" href="#二进制" aria-hidden="true">#</a></h2><p>跟阿拉伯数字系统一样，计算机内部也是利用位序来表示数值，但犹豫数字电路只有通和断两种状态，所以，相当于每位上只能有两种状态，作为传统，我们将用0和1来表示这两种状态。</p><p>然后我们就会看到计算机努力的表示数字： $0,1,10,11,100,101,110,111,1000,1001,1010$ 等你都觉得脑袋大了，计算机才数到10，不过其实关于这个问题并不需要你操心太多，反正跟阿拉伯数字一样，只要足够长，任意大的数都可以表示。</p><p>可是我们之前使用的过程告诉我们，其实并不是这样的。为什么呢？</p><h3 id="定长" tabindex="-1">定长 <a class="header-anchor" href="#定长" aria-hidden="true">#</a></h3><p>既然计算机表示数字就是靠0和1，那么如果我要表示多个数字，怎么来区分呢？</p><p>比如，你知道下面究竟是1，2，3，4还是13, 14？</p><div class="language-javascript"><pre><code><span class="token number">11011100</span>
</code></pre></div><p>于是其实我们可以思考一下，出了数值，还有什么可以利用的。</p><p>长度。（以及其实你也可以用霍夫曼编码。）</p><p>当我规定用于表示数据的长度必须是一定（比如4位）的时候，表示数据就特别地清晰了：</p><div class="language-javascript"><pre><code><span class="token number">0001</span> <span class="token number">0010</span> <span class="token number">0011</span> <span class="token number">0100</span>
</code></pre></div><p>就可以表示1，2，3，4这四个数。而上面那个我们理解不了的序列，也可以解释成13，14这两个数。</p><p>当你去规定一种解释二进制序列的方法的时候，其实你就是在定义一种<strong>编码</strong>。</p><p>二进制序列中，每个0或者1，叫一个bit（位），特定长度（一般是8）的基本解释单位，叫做byte（字节），这个特定长度，据说是依据当前系统中表示基本的字符编码的长度来确定。</p><p>换句话说，编码不仅仅是能用来表示数字的。</p><h2 id="ascii" tabindex="-1">ASCII <a class="header-anchor" href="#ascii" aria-hidden="true">#</a></h2><p>现在提到字节大家都会反应是8位，就是因为这个东西。</p><p>全名叫American Standard Code for Information Interchange（美国标准信息交换码）。</p><p>这套代码从上世纪60年代一致用到现在，足以说明有多么经典。然而我们先不说他是什么，简单的从我们自己的角度出发先设计一套东西。</p><h3 id="字符集" tabindex="-1">字符集 <a class="header-anchor" href="#字符集" aria-hidden="true">#</a></h3><p>要知道美国人民的生活很是单调的，每天就面临大小写加起来四十多个字母，十个阿拉伯数字，以及十多个常用的标点符号。对比起来，深深地为自己的母语感到自豪。</p><p>当然，美国人民日常使用的字符量少，在信息化的时代，其实是有优势的，比如，把他们常用的字符加起来也就100个左右，而$2^{6} \lt 100 \lt 2^7$，所以我们只要有长度为7位的二进制串长度就能把美国人民用的那些字符给完全表示出来。</p><p>比如我们可以定义，0000000 ～ 0001001 表示数字字符0-9， 0100001 ～ 0111010 表示大写字母字符的A-Z，1000001 ～ 1011010表示小写字母字符的a-z，于是我们就能对把对应的字母变成相应的编码了。</p><p>但是老是这样看着满屏的0和1，总是会感觉眼花。既然都是表示数据，并不是说相同的东西，计算机看到长什么样子，我们就要看一样的。只要是能够表示相同的数据，完全可以换一种我们更习惯的方式来表示。</p><h3 id="十六进制" tabindex="-1">十六进制 <a class="header-anchor" href="#十六进制" aria-hidden="true">#</a></h3><p>比如我们可以使用十六进制（Hexadecimal）代替二进制（Binary），也就是说，同一个位上面共有16个状态，习惯上分别用0-9加上a-f来表示，同时，为了与十进制表示进行区分，一般会加上0x前缀或者h后缀。对于刚刚的字符编码来说，就可以用0x00 ～ 0x09 表示 数字字符，0x21 ～ 0x3A 表示大写字母A-Z，0x40 ～ 0x5A表示小写字母a-z。</p><h4 id="为什么是十六进制而不是其他的十二进制或者十八、二十四进制呢？" tabindex="-1">为什么是十六进制而不是其他的十二进制或者十八、二十四进制呢？ <a class="header-anchor" href="#为什么是十六进制而不是其他的十二进制或者十八、二十四进制呢？" aria-hidden="true">#</a></h4><p>我们可以简单的做一个对比：</p><div class="language-"><pre><code>Bin 0001 0010 0011 .... 1010 1011 1100 1101 1110 1111
Hex    1    2    3         A    B    C    D    E    F
Dec    1    2    3        10   11   12   13   14   15
</code></pre></div><p>十六进制的一位刚好一一对应二进制的每四个位。</p><p>于是本来用二进制表示起来很冗长的东西，用十六进制可以比较轻松的表述出来。而且相互之间的转换也很容易。</p><p>相反生活中常用的十进制跟二进制对应的就不那么协调，所以一般也比较少用，只要知道对应的位上的值就好。</p><p>也就是说，只要能够数</p><p>$$ 1,2,4,8,16,...,1024,2048,...,32768,65536, 131072,...,2147483648 $$</p><p>嗯，我觉得如果你玩过2048的话一定不会对前面的那些数字感到陌生。</p><h3 id="ascii-1" tabindex="-1">ASCII <a class="header-anchor" href="#ascii-1" aria-hidden="true">#</a></h3><p>嗯，ASCII跟我们想的一样，选择了8位作为实际的长度，同时加入了一些必须要用到的特殊字符（比如制表符tab 0x09，回车记号carriage return 0x0D，换行符line feed 0x0A..），以及一些控制字符（比如空字符NUL 0x00，文件结束符EOF等）。于是整体的设计相对于我们的想法有一些偏移：</p><ul><li><code>\x30</code> ～ <code>\x39</code> 表示0-9</li><li><code>\x41</code> ～ <code>\x5a</code> 表示A-Z</li><li><code>\x61</code> ～ <code>\x7a</code> 表示a-z</li></ul><p>好的我们来试试吧：</p><div class="language-javascript"><pre><code><span class="token string">&#39;\x41&#39;</span>
</code></pre></div><p>我们可以直接用引号<code>&#39;</code>括起来单个字符，在程序中直接拿来使用。同时也可以反过来看：</p><div class="language-javascript"><pre><code><span class="token keyword">let</span> a_char <span class="token operator">=</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">;</span>
a_char<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="cjk字符集" tabindex="-1">CJK字符集 <a class="header-anchor" href="#cjk字符集" aria-hidden="true">#</a></h3><p>CJK（有时候也会带上V），是China，Japan，Korea（和Vietnam）的统称，在这些地区，因为同遗传自古汉语，字符的数量可是非常之多，8位的ASCII根本就没办法保存这么多东西。</p><p>于是随着各种语言诞生了各种编码，比如<code>GB2312</code> 简体中文，<code>Big-5</code> 繁体中文，<code>Shift-JIS</code> 日文等。这些编码并不是相互兼容的，于是一般对于特定的内容，需要专门指出其编码。同样地，当你尝试去一种编码来解释另外一种编码的文本时，就会出现<strong>乱码</strong>的情况。注意这个时候并不是你电脑中毒了。</p><h3 id="unicode" tabindex="-1">Unicode <a class="header-anchor" href="#unicode" aria-hidden="true">#</a></h3><p>所以就有人想，不如把所有的编码都统一了吧，于是就出现了Unicode。</p><p>现行版本的Unicode加入了世界上能够找到的绝大多数语言的符号（嗯，包括emoji），然后将这些符号分类整理，统一编码。于是，在理想情况下，大家都使用Unicode字符集的话，就不会出现乱码的错误了。</p><p>Unicode包含的字符量足够的多，于是就要设计比ASCII更充分大的表示方式才能够容纳所有的符号。最初选择的是每个字符使用16位的二进制串来表示，这样的话一个中文字符虽然会超出8位范围之外，还是能够表示得出来，这种方法被称为UTF-16。</p><p>然而不久就发现，符号的数量（就算仅仅是中文字符）远远多于65536个，于是又进一步地扩充到了32位，可以表示到上亿个字符了，目前为止还要很久才会资源枯竭，这种方法类似地，被称为UTF-32。</p><p>然而UTF-32有个很致命的缺点。</p><p>对于西方人来说，并没有CJKV地区的人的需求，1个字节就能足够表示他们的符号，而UTF-32硬生生地为了统一，要求字母字符也要用4个字节来表示，这样就让空间整整大了4倍，而且另外3倍的空间完全是浪费掉的，没有任何作用。</p><p>但是，为了兼容，没办法。</p><h3 id="utf-8" tabindex="-1">UTF-8 <a class="header-anchor" href="#utf-8" aria-hidden="true">#</a></h3><p>于是为了解决这个浪费空间的问题，UTF-8出现了。这是来自Ken Thompson的设计，他给整个IT界贡献了不少东西，Unix、C语言、UTF-8。</p><p>简单来说就是，在保持与ASCII兼容的情况下，通过添加一些标记来支持更长的编码。</p><p>具体的做法当然维基百科介绍的比我更清楚，这里提起来只是要说这么一个思路：变长编码（Variable-Width Encoding）。因为比较重要的就是在设计的过程中考虑变量和不变量，以及设置各种标志和不同的数据区块解释方式，这样就可以把简单的二进制序列变成我们想要的任意数据。</p><p>当然，这里的思想我们会在第6章详细地展开。</p><h2 id="数系的扩充" tabindex="-1">数系的扩充 <a class="header-anchor" href="#数系的扩充" aria-hidden="true">#</a></h2><p>你有没有尝试计算JavaScript里面<code>1/3</code>的结果？</p><p>当我们需要小数的时候又该如何表示呢？</p><p>这个问题留作练习。</p><p>作为参考答案，你可以搜索IEEE754。</p></div></div><footer class="page-footer" data-v-7eddb2c4 data-v-fb8d84c6><div class="edit" data-v-fb8d84c6><div class="edit-link" data-v-fb8d84c6 data-v-1ed99556><!----></div></div><div class="updated" data-v-fb8d84c6><!----></div></footer><div class="next-and-prev-link" data-v-7eddb2c4 data-v-38ede35f><div class="container" data-v-38ede35f><div class="prev" data-v-38ede35f><a class="link" href="/ch03_procedure" data-v-38ede35f><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-prev" data-v-38ede35f><path d="M19,11H7.4l5.3-5.3c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-7,7c-0.1,0.1-0.2,0.2-0.2,0.3c-0.1,0.2-0.1,0.5,0,0.8c0.1,0.1,0.1,0.2,0.2,0.3l7,7c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.4,13H19c0.6,0,1-0.4,1-1S19.6,11,19,11z"></path></svg><span class="text" data-v-38ede35f>过程</span></a></div><div class="next" data-v-38ede35f><a class="link" href="/ch05_sequence" data-v-38ede35f><span class="text" data-v-38ede35f>序列</span><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-next" data-v-38ede35f><path d="M19.9,12.4c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-7-7c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l5.3,5.3H5c-0.6,0-1,0.4-1,1s0.4,1,1,1h11.6l-5.3,5.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l7-7C19.8,12.6,19.9,12.5,19.9,12.4z"></path></svg></a></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"glossary.md\":\"b93c45f8\",\"summary.md\":\"a7cd9f93\",\"ch01_environment.md\":\"f6bec722\",\"ch02_computation.md\":\"d35dc0f5\",\"ch03_procedure.md\":\"96284ceb\",\"ch04_encoding.md\":\"869302a4\",\"ch05_sequence.md\":\"0824aac4\",\"ch06_data.md\":\"432da640\",\"ch07_state.md\":\"cc3a100a\",\"ch08_reference.md\":\"8799898c\",\"ch09_closure.md\":\"81452677\",\"ch10_object.md\":\"f22df407\",\"ch11_concurrency.md\":\"ab368c0b\",\"index.md\":\"b9ce94fd\",\"intro.md\":\"5b7292a2\",\"stream.md\":\"a705d840\"}")</script>
    <script type="module" async src="/assets/app.2fe5d9c1.js"></script>
    
  </body>
</html>