<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>数据 | 编程导引</title>
    <meta name="generator" content="VuePress 1.8.0">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.fab77d47.css" as="style"><link rel="preload" href="/assets/js/app.044a73b6.js" as="script"><link rel="preload" href="/assets/js/2.a6b4d3f7.js" as="script"><link rel="preload" href="/assets/js/16.a86e498d.js" as="script"><link rel="prefetch" href="/assets/js/10.790934bf.js"><link rel="prefetch" href="/assets/js/11.fff91efd.js"><link rel="prefetch" href="/assets/js/12.9a9ccdf4.js"><link rel="prefetch" href="/assets/js/13.6fefa875.js"><link rel="prefetch" href="/assets/js/14.c7690e28.js"><link rel="prefetch" href="/assets/js/15.b68eec02.js"><link rel="prefetch" href="/assets/js/17.bf626061.js"><link rel="prefetch" href="/assets/js/18.ba7f1098.js"><link rel="prefetch" href="/assets/js/19.d20e9506.js"><link rel="prefetch" href="/assets/js/20.48f57deb.js"><link rel="prefetch" href="/assets/js/21.ac36cf73.js"><link rel="prefetch" href="/assets/js/22.8bc0e292.js"><link rel="prefetch" href="/assets/js/23.9bedfd09.js"><link rel="prefetch" href="/assets/js/3.1dc73659.js"><link rel="prefetch" href="/assets/js/4.ae8c1532.js"><link rel="prefetch" href="/assets/js/5.21b03e7f.js"><link rel="prefetch" href="/assets/js/6.4ba1f82e.js"><link rel="prefetch" href="/assets/js/7.f94e8170.js"><link rel="prefetch" href="/assets/js/8.cb698648.js"><link rel="prefetch" href="/assets/js/9.e100d8a0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.fab77d47.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">编程导引</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/book/" class="nav-link router-link-active">
  编程导引
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/book/" class="nav-link router-link-active">
  编程导引
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/book/" aria-current="page" class="sidebar-link">引言</a></li><li><a href="/book/ch.01.environment.html" class="sidebar-link">环境</a></li><li><a href="/book/ch.02.computation.html" class="sidebar-link">计算</a></li><li><a href="/book/ch.03.procedure.html" class="sidebar-link">过程</a></li><li><a href="/book/ch.04.encoding.html" class="sidebar-link">编码</a></li><li><a href="/book/ch.05.sequence.html" class="sidebar-link">序列</a></li><li><a href="/book/ch.06.data.html" aria-current="page" class="active sidebar-link">数据</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/ch.06.data.html#结构" class="sidebar-link">结构</a></li><li class="sidebar-sub-header"><a href="/book/ch.06.data.html#递归数据类型" class="sidebar-link">递归数据类型</a></li><li class="sidebar-sub-header"><a href="/book/ch.06.data.html#构造器-constructor" class="sidebar-link">构造器（Constructor）</a></li><li class="sidebar-sub-header"><a href="/book/ch.06.data.html#递归结构上的操作" class="sidebar-link">递归结构上的操作</a></li><li class="sidebar-sub-header"><a href="/book/ch.06.data.html#树" class="sidebar-link">树</a></li></ul></li><li><a href="/book/ch.07.state.html" class="sidebar-link">状态</a></li><li><a href="/book/ch.08.reference.html" class="sidebar-link">引用</a></li><li><a href="/book/ch.09.closure.html" class="sidebar-link">闭包</a></li><li><a href="/book/ch.10.object.html" class="sidebar-link">对象</a></li><li><a href="/book/ch.11.concurrency.html" class="sidebar-link">并发</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="数据"><a href="#数据" class="header-anchor">#</a> 数据</h1> <p>很多时候我们要处理的东西并不只是一个简单的数据，或者是一个由多个数据组成的简单序列。比如，当我们要考虑一间房子，关注的是户型、面积和位置等，考虑一辆汽车，关注的是性价比、能耗和易用性等，考虑一个学生，关注的是他的学号、姓名、各科成绩等。</p> <p>很多时候我们也需要考虑一系列的符号，比如房屋的户型、汽车的品牌，这些在一定程度上固定的内容，并不需要专门去用字符串处理。</p> <p>这种时候，序列、引用和各种标量（Scalar）类型都不能很好的满足我们的需要。</p> <p>我们来做一个简单的示范吧。</p> <h2 id="结构"><a href="#结构" class="header-anchor">#</a> 结构</h2> <p>比如，我们要表示一辆车，其中包括他的品牌、价格和最高时速。在当前的情况下，最合适的方式就是采用长度为3的array，约定好第0位表示品牌，第1位表示价格，第2位表示最高时速。于是我们可以得到以下的设计：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> car <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">500000</span><span class="token punctuation">,</span> <span class="token number">180</span><span class="token punctuation">]</span>
</code></pre></div><p>于是我们就能够很轻松地（并丑陋地）表示汽车了。</p> <p>这种写法虽然算是比较方便，但是还是有很多问题的。</p> <p>比如，每次我们都需要多写很多个函数，比如所有的元素都必须是同一个类型的。</p> <p>所以大多数编程语言都提供结构（Structure）或者记录（Record）类型，来简化我们实现这个的过程。</p> <p>比如，在JavaScript中我们可以很简单的把Car表示如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> car <span class="token operator">=</span> <span class="token punctuation">{</span>
    brand<span class="token operator">:</span> <span class="token string">'Nissan'</span><span class="token punctuation">,</span>
    price<span class="token operator">:</span> <span class="token number">500000</span><span class="token punctuation">,</span> <span class="token comment">// USD</span>
    speed<span class="token operator">:</span> <span class="token number">180</span> <span class="token comment">// MPH</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是一个结构（struct），其中包含了三个域（field，也叫字段）。比起还要反复地写各种函数来，要简单和方便很多。 而且，各个字段的类型可以不同。</p> <p>这样子我们就能通过Car来表示一辆汽车了：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>car<span class="token punctuation">.</span>brand
</code></pre></div><p>很简单吧。</p> <p>那么，结构的本质到底是什么呢？</p> <p>回到本章开始我们的讨论。房子、汽车、学生，这些概念性的实体（Entity）都有一些自己本身的属性（Property），以及与其他实体之间的关系（Relation）。 我们可以给这些实体的属性和关系贴上一个个标签，把他们与所属的实体之间关联起来。这样就组成了我们现在看到的结构。</p> <p>当然，他还是数据，但是这些数据通过我们贴上不同的标签以及把他们关联组合，就变成了更加具有实际意义的内容。换句话说，我们给一块二进制内存区赋予了语义（Semantics）。</p> <p>来让我们看一下其他的许多结构吧。</p> <p>复数，</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>let complex <span class="token operator">=</span> <span class="token punctuation">{</span>
    real<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    image<span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>分数，</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>let frac <span class="token operator">=</span> <span class="token punctuation">{</span>
    numerator<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    denominator<span class="token operator">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>甚至是，用数据代替表达式，</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>let arith <span class="token operator">=</span> <span class="token punctuation">{</span>
    optr<span class="token operator">:</span> <span class="token string">'+'</span>
    leftOperand<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    rightOperand<span class="token operator">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>以及，更多复杂的结构。</p> <h2 id="递归数据类型"><a href="#递归数据类型" class="header-anchor">#</a> 递归数据类型</h2> <p>看到这里也许你开始担忧了。什么是递归数据结构（Recursive Data Type）？</p> <p>这里我们要拿前面提到的一个例子来说事儿了。</p> <p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Cons-cells.svg/320px-Cons-cells.svg.png" alt="list"></p> <p>看这张图，去掉这个list的第一个节点，结果得到的还是一个list。同样地，在这个节点上面再加一个节点，得到的也依然还是一个list。</p> <p>也就是说，这个list的每一个节点大概对应到下面的结构：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
    ListNode<span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>我们试着用这个结构建立一个列表。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>ListNode a<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
ListNode b<span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">}</span><span class="token punctuation">;</span>
ListNode c<span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>从<code>c</code>出发，我们就能够依次遍历完<code>b</code>、<code>a</code>，而且对于每一个节点，处理的方式基本一致。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">printList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> list<span class="token operator">-&gt;</span>value<span class="token punctuation">;</span>
    <span class="token function">printList</span><span class="token punctuation">(</span>list<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>没错，list就是递归的。每一个list节点都包含一个list的引用。这样我们就能够利用递归来对其进行操作了。</p> <p>比如我们想要构造一个新的list，也可以把他做成递归的。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">List</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span>List<span class="token operator">&gt;</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

shared_ptr<span class="token operator">&lt;</span>List<span class="token operator">&gt;</span> <span class="token function">make_cell</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">,</span> shared_ptr<span class="token operator">&lt;</span>List<span class="token operator">&gt;</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> cell <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span>List<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cell<span class="token operator">-&gt;</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
    cell<span class="token operator">-&gt;</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token keyword">return</span> cell<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">&gt;</span>
shared_ptr<span class="token operator">&lt;</span>List<span class="token operator">&gt;</span> <span class="token function">make_list</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">,</span> Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">make_cell</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token function">make_list</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
shared_ptr<span class="token operator">&lt;</span>List<span class="token operator">&gt;</span> <span class="token function">make_list</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">make_cell</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="构造器-constructor"><a href="#构造器-constructor" class="header-anchor">#</a> 构造器（Constructor）</h2> <p>看我们的<code>make_cell</code>函数，其实就是创建了一个<code>shared_ptr</code>，然后再利用传入的参数来对cell中的数据进行初始化。当然这意思其实已经很明确了，<code>make_cell</code>作为创建一个新的cell结构的函数而存在。</p> <p>但是这样未免太罗嗦，每次我创建一个struct的时候都要再去考虑怎么设计一个用来专门创建实例的函数。JavaScript提供了一种叫做构造器的函数，可以简化这个过程。加入了构造器的List定义如下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span>List<span class="token operator">&gt;</span> next<span class="token punctuation">;</span>

    <span class="token function">List</span><span class="token punctuation">(</span><span class="token keyword">int</span> _value<span class="token punctuation">,</span> shared_ptr<span class="token operator">&lt;</span>List<span class="token operator">&gt;</span> _next<span class="token punctuation">)</span><span class="token operator">:</span>
        <span class="token function">value</span><span class="token punctuation">(</span>_value<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span>_next<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里的构造器是说，我接受两个参数（<code>_next</code>, <code>_value</code>），然后用这两个参数去初始化JavaScript结构（struct）中的字段。</p> <p>然后我们可以把整个make_cell函数改成</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>make_shared<span class="token operator">&lt;</span>List<span class="token operator">&gt;</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>构造器能够让我们以一种很直观的方式来创建和使用数据。 比如:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">double</span> height<span class="token punctuation">;</span>

    <span class="token function">User</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string _name<span class="token punctuation">,</span> <span class="token keyword">int</span> _age<span class="token punctuation">,</span> <span class="token keyword">double</span> _height<span class="token punctuation">)</span><span class="token operator">:</span>
        <span class="token function">name</span><span class="token punctuation">(</span>_name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">age</span><span class="token punctuation">(</span>_age<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">height</span><span class="token punctuation">(</span>_height<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> user <span class="token operator">=</span> User<span class="token punctuation">{</span><span class="token string">&quot;Kimmy&quot;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">178.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>没错，这样看上去跟前面定义的Car类型没有什么区别。但是当结合上默认值参数以及需要在数据初始化的时候做一些其他操作的时候，构造器给提供了很直接的方案。后面我们会进一步地看到这种方案的优点。（当然你也可以去看一看什么是RAII。）</p> <h2 id="递归结构上的操作"><a href="#递归结构上的操作" class="header-anchor">#</a> 递归结构上的操作</h2> <p>好的我们回到刚刚的List上来。</p> <p>我们已经可以通过make_list来创建一个整数的列表了，那么，作为一个递归的结构，我们当然也可以通过递归来对齐定义一些操作。</p> <p>比如把List里面的每一个元素做一个转换。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>shared_ptr<span class="token operator">&lt;</span>List<span class="token operator">&gt;</span> 
<span class="token function">transform</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>List<span class="token operator">&gt;</span> list<span class="token punctuation">,</span> std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> transformer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> make_shared<span class="token operator">&lt;</span>List<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function">transformer</span><span class="token punctuation">(</span>list<span class="token operator">-&gt;</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">transform</span><span class="token punctuation">(</span>list<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span> tranformer<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>


<span class="token comment">// =&gt; {-1, -2, -3, -4, -5}</span>
<span class="token function">transform</span><span class="token punctuation">(</span><span class="token function">make_list</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">-</span>i<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="作为数据的过程-procedure-as-data"><a href="#作为数据的过程-procedure-as-data" class="header-anchor">#</a> 作为数据的过程（Procedure as data）</h3> <p>当然，看到上面那段代码你会是满头雾水。<code>std::function&lt;int(int)&gt;</code>是什么，<code>[](){}</code>放在一起又是什么。</p> <p>回过头去想想，我们是不是可以定义一些过程，然后对这个过程进行调用，去做一些复杂的计算？同时，当我们需要进一步利用这些过程的时候，可以把它们直接当成数据拿来用的。于是我们可以约束他们的类型，然后根据这些约束再进一步地做抽象。</p> <p>比如第三章中的pow，类型就是<code>std::function&lt;int(int, int)&gt;</code>，接收两个整数，返回他们的乘方，结果也是整数。</p> <p>而有些时候我们可能并不只是需要拿已经就有的过程来简单地做抽象，所以更有必要提供一种方式让我们随时都能够创建一个过程。于是JavaScript给我们提供了Lambda表达式（Lambda Expression，在其他语言里面也可能叫做匿名函数/过程，Anonymous Function/Procedure），比如</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> negate<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">-</span>i<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>我们就地创建了一个lambda表达式，然后把它赋值给了negate。这个lambda表达式所表示的就是一个匿名过程，它会接收一个整数，然后返回这个数的相反数。</p> <p>于是当我们再去回过头看transform的时候，就不会觉得太突兀了。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>shared_ptr<span class="token operator">&lt;</span>List<span class="token operator">&gt;</span> 
<span class="token function">transform</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>List<span class="token operator">&gt;</span> list<span class="token punctuation">,</span> std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> transformer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> make_shared<span class="token operator">&lt;</span>List<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function">transformer</span><span class="token punctuation">(</span>list<span class="token operator">-&gt;</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">transform</span><span class="token punctuation">(</span>list<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span> tranformer<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>transform接收一个List和一个<code>int(int)</code>类型的transformer，然后在这个List上递归地对每一个元素执行transformer，得到一个新的结果，然后组成一个新的List。</p> <h2 id="树"><a href="#树" class="header-anchor">#</a> 树</h2> <p>好的我们来看另外一种递归数据类型，树。更确切地说，是二叉树（Binary Tree）。</p> <div class="language-C++ extra-class"><pre class="language-text"><code>struct Tree {
    int value;
    shared_ptr&lt;Tree&gt; left;
    shared_ptr&lt;Tree&gt; right;

    Tree(int _v, shared_ptr&lt;Tree&gt; _l, shared_ptr&lt;Tree&gt; _r): 
        value(_v), left(_l), right(_r) {}
};
</code></pre></div><p>也就是说，Tree是这种结构，他的左侧是Tree，右侧也是Tree。而且Tree的每个节点都会带有一个value。</p> <p>当然你还是会怀疑说这种无聊的结构拿来有什么用。那我们看下面的内容：</p> <div class="language- extra-class"><pre class="language-text"><code>             *
           /   \
          +     4
        /   \ 
       1     -
           /   \
          2     3
</code></pre></div><p>这个就是把 <mjx-container jax="SVG" display="true" class="MathJax"><svg xmlns="http://www.w3.org/2000/svg" width="16.342ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 7223.3 1000" style="vertical-align:-0.566ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389, 0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1111.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(2111.4, 0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(2500.4, 0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(3222.7, 0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(4222.9, 0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mo" transform="translate(4722.9, 0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5111.9, 0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5723.1, 0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mn" transform="translate(6723.3, 0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g></g></svg></mjx-container>作为一种树行结构来表示。</p> <h3 id="遍历-traverse"><a href="#遍历-traverse" class="header-anchor">#</a> 遍历（Traverse）</h3> <p>对于前面那个树形结构，我们可以试着从最顶端的节点写出他的value，然后再分别访问他的左右子树，按照这样的方式把所有的内容写出来，就能得到下面的结果：</p> <div class="language- extra-class"><pre class="language-text"><code>* + 1 - 2 3 4
</code></pre></div><p>这种表示方式又叫做该二叉树的先序遍历，又叫前序遍历。</p> <p>然后我们可以把属于同一个树的部分用括号包起来，就得到了：</p> <div class="language-scheme extra-class"><pre class="language-scheme"><code><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">4</span><span class="token punctuation">)</span>
</code></pre></div><p>没错这就是Lisp。</p> <p>同样地，我们可以选择先一次访问一棵树的左右子树，然后再写出器对应的value，这样一层层递进下去。我们能够得到如下的结果：</p> <div class="language- extra-class"><pre class="language-text"><code>1 2 3 - + 4 *
</code></pre></div><p>如果你有了解过的话，就能看得出来这跟forth或者PostScript很像，当然他也叫上面那个二叉树的后序遍历。</p> <p>当然还有一种叫做中序遍历的过程，得到的结果是：</p> <div class="language- extra-class"><pre class="language-text"><code>1 + 2 - 3 * 4
</code></pre></div><p>跟最初的算术表达式的区别就在于没有了括号。当然，本来表示的意思也丧失了。</p> <p>对于前序遍历和后序遍历的结果，并不会改变整个表达式的语义，只是重新定义了这个表达式的解析方式。</p> <blockquote><h4 id="练习"><a href="#练习" class="header-anchor">#</a> 练习</h4> <p>请尝试用代码实现先序、中序和后序遍历。</p></blockquote> <h3 id="深度优先-depth-first-和广度优先-breath-first"><a href="#深度优先-depth-first-和广度优先-breath-first" class="header-anchor">#</a> 深度优先（Depth-First）和广度优先（Breath-First）</h3> <p>前面我们提到的遍历，是对整个树进行访问的过程。如果我们只需要从根节点出发，然后去寻找某个指定元素的话，可以有这样两种选择。</p> <p>第一种是遇到有分支，我们就选择一个方向继续往前走，直到走到不能再继续，然后再一步步返回，同时在返回的过程中尝试其他的分支。</p> <p>这种首先走到最底端然后再慢慢回来的过程叫做深度优先查找（Depth-First Search）。</p> <p>比如前文中的那个表达式树，整个过程就是</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token operator">*</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span>后退<span class="token operator">&gt;</span> <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">&lt;</span>后退<span class="token operator">&gt;</span> <span class="token number">3</span> <span class="token operator">&lt;</span>后退<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>后退<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>后退<span class="token operator">&gt;</span> <span class="token number">4</span>
</code></pre></div><p>也就是说，我们需要访问整个树才能查找到4。</p> <p>另外一种方式是，遇到分支，我们先把对应的分支的每一个第一层先访问一遍，再一步步走到下一层。</p> <p>这样的过程叫做广度优先查找（Breath-First Search）。比如</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token operator">*</span> <span class="token operator">&lt;</span>下一层<span class="token operator">&gt;</span> <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">&lt;</span>下一层<span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">-</span> <span class="token operator">&lt;</span>下一层<span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token number">3</span>
</code></pre></div><p>这个时候我们如果要查找4的话，只要在第一层就可以了。</p> <h3 id="栈-stack-与队列-queue"><a href="#栈-stack-与队列-queue" class="header-anchor">#</a> 栈（stack）与队列（queue）</h3> <p>我们仔细思考一下怎么实现DFS和BFS。</p> <p>对于DFS，我们需要考虑如果找不到如何返回，所以我们可以先试着模拟一下DFS查找4的流程。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>path            description
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>      <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
<span class="token operator">*</span>               <span class="token comment">//step 1</span>
<span class="token operator">*</span> <span class="token operator">+</span>             <span class="token comment">//step 2</span>
<span class="token operator">*</span> <span class="token operator">+</span> <span class="token number">1</span>           <span class="token comment">//step 3 and 1 has no childs</span>
<span class="token operator">*</span> <span class="token operator">+</span>             <span class="token comment">//get back to +</span>
<span class="token operator">*</span> <span class="token operator">+</span> <span class="token operator">-</span>           <span class="token comment">//step 4</span>
<span class="token operator">*</span> <span class="token operator">+</span> <span class="token operator">-</span> <span class="token number">2</span>         <span class="token comment">//step 5 and no childs</span>
<span class="token operator">*</span> <span class="token operator">+</span> <span class="token operator">-</span>           <span class="token comment">//get back to -</span>
<span class="token operator">*</span> <span class="token operator">+</span> <span class="token operator">-</span> <span class="token number">3</span>         <span class="token comment">//step 6 and no childs</span>
<span class="token operator">*</span> <span class="token operator">+</span> <span class="token operator">-</span>           <span class="token comment">//get back to - and no more childs to visit</span>
<span class="token operator">*</span> <span class="token operator">+</span>             <span class="token comment">//get back to + and no more childs to visit</span>
<span class="token operator">*</span>               <span class="token comment">//get back to *</span>
<span class="token operator">*</span> <span class="token number">4</span>             <span class="token comment">//step 7 found!</span>
</code></pre></div><p>可以看到，每次当遇到无法继续的节点，都会有一步回退操作，其实就是把path中加入进去内容的再取出来，这种一般最后进入但是最先退出（Last In First Out，LIFO）的结构我们常常称作是栈（stack）。栈通常会用来辅助实现一些拥有LIFO特性的过程，比如过程调用，也有一个对应的调用栈（call stack）。</p> <p>比如当我们调用递归函数pow(2, 5)，对应的调用栈展开如下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>                 <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span>
    <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>             <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span>
        <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>         <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span>
            <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>     <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span>
                <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">2</span>
</code></pre></div><p>这也就是在第三章我提到“栈溢出”中的“栈”的含义。当一个调用栈太大而超出了当前系统规定的范围以后，就会造成这种问题。</p> <p>我们接下来看BFS，模拟一下它查找3的流程：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>path            description
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>      <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> 
<span class="token operator">*</span>               <span class="token comment">//step 1</span>
<span class="token operator">*</span> <span class="token operator">+</span> <span class="token number">4</span>           <span class="token comment">//push childs and move to next</span>
<span class="token operator">+</span> <span class="token number">4</span>             <span class="token comment">//step 2</span>
<span class="token operator">+</span> <span class="token number">4</span> <span class="token number">1</span> <span class="token operator">-</span>         <span class="token comment">//push childs and move to next</span>
<span class="token number">4</span> <span class="token number">1</span> <span class="token operator">-</span>           <span class="token comment">//step 3 no childs move to next</span>
<span class="token number">1</span> <span class="token operator">-</span>             <span class="token comment">//step 4 no childs move to next</span>
<span class="token operator">-</span>               <span class="token comment">//step 5</span>
<span class="token operator">-</span> <span class="token number">2</span> <span class="token number">3</span>           <span class="token comment">//push childs and move to next</span>
<span class="token number">2</span> <span class="token number">3</span>             <span class="token comment">//step 6 no childs move to next</span>
<span class="token number">3</span>               <span class="token comment">//step 7 found!</span>
</code></pre></div><p>与DFS的后进先出不同的是，BFS会把先放入的东西给拿出去，也就是先进先出（First In First Out，FIFO）。用于实现FIFO的结构我们一般叫做队列（queue）。当然队列的应用也很广泛，特别是需要考虑进入的先后顺序，通常都是作为一种特殊的队列来处理。</p> <h3 id="树-2"><a href="#树-2" class="header-anchor">#</a> 树</h3> <p>树反应了具有某种特定结构的层级关系。当然这种结构并不一定是只有两个分支的，也并不一定非得是考虑顺序的。当我们在建模的时候，遇到层级结构，就可以考虑设计成一棵树。另外，递归。</p> <blockquote><h4 id="练习-2"><a href="#练习-2" class="header-anchor">#</a> 练习</h4> <p>尝试用代码实现DFS和BFS。</p></blockquote></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/book/ch.05.sequence.html" class="prev">
        序列
      </a></span> <span class="next"><a href="/book/ch.07.state.html">
        状态
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.044a73b6.js" defer></script><script src="/assets/js/2.a6b4d3f7.js" defer></script><script src="/assets/js/16.a86e498d.js" defer></script>
  </body>
</html>
